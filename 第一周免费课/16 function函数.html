<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script type="text/javascript">

    //function:函数数据类型、相当于一个方法或者一个功能
    //定义一个函数的步骤
    //1、开辟一个新的空间地址xxxfff1111
    //2、把函数体中的js代码当做字符串存到空间里面（一个函数如果只是定义了，并没有执行，这个函数没有任何意义）
    //3、在把我们的地址给我们的函数名

//    function fn(){
//        //函数体
//        //一个功能或者一个方法实现的步骤
//        alert("欢迎大家来到珠峰培训");
//    }
//    fn();//执行这个函数，函数执行目的：把函数之前存储的那些字符串变为JS代码，然后让JS代码从上到下依次执行
    //首先会形成一个自己的私有底盘
    //然后把定义的时候存在空间的js代码字符串当做js代码执行
    //

// function sum(){
//     var num=1;
//     num+=3;
//     num*=5;
//     console.log(num);
// }
//    sum();
//    sum();
//    sum();

    //js中function的一个特别大的作用：将实现一个功能的代码进行封装，以后如果用到了这个功能，代码没有必要重新写


//    function sum(){
//        var a=1;
//        var b=1;
//        console.log(a+b);
//    }
//    sum;代表当前函数本身
//    sum()代表的是执行当前函数
//
//    //第一次升级，形参：可以理解为是一个变量（多态：一个功能的多种形态,通过参数的不同实现不同的功能）
//    //作用：实现一个功能，发现部分原材料没有，在制定计划时我们没有办法获取，我们就把需要的原材料定义在我们的形参上
//    //在执行的计划的时候，把原材料提供了就好了
//    function sum(a,b){
//        var total=0;
//        //用typeof检测形参是否有传递进来值
//        if(typeof num1!="undefined"){
//           total+=num1;
//        }
//        if(typeof num2!="undefined"){
//            total+=num2;
//        }
//        console.log(total);
//    }
//    sum(1,1);
//    sum(2);//定义一个形参变量，执行的时候没有传递值，默认值是undefined    ====>NaN

    //arguments:是函数内置接收参数的机制
    //内置：天生自带的，不管你是否传递了参数，也不管写没写形参，arguments一直存在
    //arguments也是一个类数组（有数字作为索引，索引从0开始代表第几个传递的参数）
    //length：代表传递了几个参数
    //callee:argument.callee代表的就是当前函数本身
    //arguments获取其中的某一个只能用arguments[索引]
    //任意数求和
    function fn(){
        var total=0;
        for(var i=0;i<arguments.length;i++){
            var cur=arguments[i];
            cur=Number(cur);
            if(isNaN(cur)===false){
                total+=cur;
            }
        }
        //console.log(total);
        //console.log(arguments.length);
        return total;//外面想用什么，在函数里面直接return返回就可以了，函数执行完成的整体就是这个值
    }
   var total= fn(1,2,"a");//把函数执行完成的整体返回值赋给外面的total这个变量
   console.log(total*=3);

    //如果我们没有写return(或者return;)，默认的返回结果是undefined

    //在函数体中，遇到return，后面的代码不再执行：return的第二个作用：控制函数体中的代码执行到指定位置

    //函数执行的时候会形成一个私有底盘（函数里面定义的变量，在外面不能直接使用）

    //闭包：函数执行的时候会形成一个新的作用域来保护里面的变量，不受外界干扰，我们把这种保护机制，称为闭包

    //console.dir 比console.log在控制台输出的更详细


    //上面都是实名函数，匿名函数
    //函数表达式：把一个匿名函数定义部分当做一个值，赋值给一个变量，或者一个元素的事件
    //例如： var fn=function(){
    // }

//    var oBody=document.getElementById("bodyEle");
//    oBody.onclick=function(){
//
//    }
    //自执行函数：定义和执行一起完成

    //预解释是发生在当前作用域下的，刚开始只声明或者定义全局下的var,或者function
    //带var 和function关键字的，进行预解释的时候是不一样的
    //var:只是提前声明
    //function:提前声明和定义都完成了
    //一个function在代码执行之前（预解释的时候）就把声明和定义完成了，在接下来执行代码过程中，如果遇到函数定义的那块代码
    //直接跳过就可以了
    //函数执行可以写在任何位置，原因是定义的这个操作在预解释就完成了，
    //函数执行会形成一个新的私有作用域（栈内存）,
    //首先：进行预解释：
    //其次是代码执行
    /*在函数的这个私有作用域中定义的变量都是私有变量，形成的这个作用域保护里面的私有变量不受外界的干扰，我们把这个机制叫
    闭包.
    函数执行一次就会形成一个新的私有作用域，上述的步骤重复一次。
    一般情况下，每一次执行完成，函数新形成的作用域都自动销毁。
    */
    //预解释是发生在当前作用域下的，


    (function(){

    })();
    !function(){}();
    +function(){}();
    -function(){}();

</script>
</body>
</html>